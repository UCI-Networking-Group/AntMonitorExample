/*
 *  This file is part of AntMonitor <https://athinagroup.eng.uci.edu/projects/antmonitor/>.
 *  Copyright (C) 2018 Anastasia Shuba and the UCI Networking Group
 *  <https://athinagroup.eng.uci.edu>, University of California, Irvine.
 *
 *  AntMonitor is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  AntMonitor is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with AntMonitor. If not, see <http://www.gnu.org/licenses/>.
 */

package edu.uci.calit2.antexample;

import android.content.Context;
import android.util.Log;

import java.nio.ByteBuffer;
import java.util.ArrayList;

import edu.uci.calit2.antmonitor.lib.logging.ConnectionValue;
import edu.uci.calit2.antmonitor.lib.util.AhoCorasickInterface;
import edu.uci.calit2.antmonitor.lib.util.TCPReassemblyInfo;
import edu.uci.calit2.antmonitor.lib.vpn.OutPacketFilter;
import edu.uci.calit2.antmonitor.lib.logging.PacketAnnotation;

/**
 * Example Packet filter that blocks all Google apps and searches for the string "Irvine"
 * in outgoing SSL packets
 *
 * @author Anastasia Shuba
 */
public class ExamplePacketFilterOut extends OutPacketFilter {

    private final String TAG = ExamplePacketFilterOut.class.getSimpleName();

    /** Annotation used for blocking packets */
    private final PacketAnnotation BLOCK_ANNOTATION = new PacketAnnotation(false);

    public ExamplePacketFilterOut(Context cxt) {
        super(cxt);

        // Initialize the AhoCorasick interface to search for the string "Irvine"
        String[] searchStrings = new String[] { "Irvine" };
        AhoCorasickInterface.getInstance().init(searchStrings);
    }

    @Override
    public PacketAnnotation acceptIPDatagram(ByteBuffer packet) {
        // Search the current packet for the string "Irvine"
        // Note: currently this functionality is not supported by the AntMonitorLibrary
        final ArrayList<String> foundStrings = AhoCorasickInterface.getInstance().
                search(packet, packet.limit());
        if (foundStrings == null || foundStrings.isEmpty())
            return DEFAULT_ANNOTATION; // String "Irvine" was not found, allow packet


        ConnectionValue cv = mapDatagramToApp(packet);
        return processFoundStrs(foundStrings, cv);
    }

    @Override
    public PacketAnnotation acceptDecryptedSSLPacket(ByteBuffer packet, TCPReassemblyInfo tcpInfo) {
        // We can do the same thing here as in the above function
        // Note: currently this functionality is not supported by the AntMonitorLibrary
        final ArrayList<String> foundStrings = AhoCorasickInterface.getInstance().
                search(packet, packet.limit());
        if (foundStrings == null || foundStrings.isEmpty())
            return DEFAULT_ANNOTATION; // String "Irvine" was not found, allow packet

        // Since the packet here does not contain headers, we must use the params function
        // to map and pass the needed info to it
        ConnectionValue cv = mapParamsToApp(tcpInfo.getRemoteIp(), tcpInfo.getSrcPort(),
                tcpInfo.getDestPort());
        return processFoundStrs(foundStrings, cv);
    }

    private PacketAnnotation processFoundStrs(ArrayList<String> foundStrings, ConnectionValue cv) {
        final int LOOP_SIZE = 2;
        for (int i = 0; i < foundStrings.size(); i += LOOP_SIZE) {
            // Each found string is followed by its position in the packet
            Log.d(TAG, "String " + foundStrings.get(i) + " was found at position " +
                    foundStrings.get(i + 1) + " in a packet generated by " + cv.getAppName());
        }

        // Block packet
        return BLOCK_ANNOTATION;
    }
}
